<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#000000" media="(prefers-color-scheme: dark)">
<link rel="manifest" href="manifest.json">
<title>Textarea</title>
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  html {
    color-scheme: light dark;
    -webkit-font-smoothing: antialiased;
    text-rendering: optimizeLegibility;

    background-color: #fff;
    --elevated: #fff;
    --link: #0066cc;
    --text: #161616;
    --outline: #007aff;

    @media (prefers-color-scheme: dark) {
      background-color: #000;
      --elevated: #121212;
      --link: #58a6ff;
      --text: #fff;
    }
  }

  body {
    color: var(--text);
  }

  a {
    color: var(--link);
    text-decoration: underline;
    text-underline-offset: 4px;
    text-decoration-thickness: 1px;
  }

  article {
    outline: none;
    padding: 18px max(18px, calc(50vw - 400px));
    width: 100%;
    min-height: 100dvh;
    font: 18px / 1.5 system-ui;
    tab-size: 4;
    white-space: pre-wrap;
    text-wrap-style: stable;
    overflow-wrap: break-word;
  }

  .md-h1,
  .md-h2,
  .md-h3,
  .md-h4,
  .md-h5,
  .md-h6 {
    font-weight: 700;
  }

  .md-h1 {
    font-size: 2em;
  }

  .md-h2 {
    font-size: 1.5em;
  }

  .md-h3 {
    font-size: 1.25em;
  }

  .md-h4 {
    font-size: 1.1em;
  }

  .md-h5 {
    font-size: 1em;
  }

  .md-h6 {
    font-size: 0.9em;
  }

  .md-code {
    font-family: monospace;
  }

  .md-codeblock {
    font-family: monospace;
  }

  .md-bold {
    font-weight: bold;
  }

  .md-strike {
    text-decoration: line-through;
  }

  .md-italic {
    font-style: italic;
  }

  .md-url {
    cursor: pointer;
  }

  /* Code Editor syntax highlighting (extensible for all languages) */
  .ce-keyword {
    color: #cf222e;
    @media (prefers-color-scheme: dark) {
      color: #ff7b72;
    }
  }

  .ce-string {
    color: #0a3069;
    @media (prefers-color-scheme: dark) {
      color: #a5d6ff;
    }
  }

  .ce-number {
    color: #0550ae;
    @media (prefers-color-scheme: dark) {
      color: #79c0ff;
    }
  }

  .ce-comment {
    color: #6e7781;
    @media (prefers-color-scheme: dark) {
      color: #8b949e;
    }
  }

  .ce-function {
    color: #8250df;
    @media (prefers-color-scheme: dark) {
      color: #d2a8ff;
    }
  }

  .ce-operator {
    color: #cf222e;
    @media (prefers-color-scheme: dark) {
      color: #ff7b72;
    }
  }

  .ce-builtin {
    color: #953800;
    @media (prefers-color-scheme: dark) {
      color: #ffa657;
    }
  }

  .ce-regex {
    color: #116329;
    @media (prefers-color-scheme: dark) {
      color: #7ee787;
    }
  }

  .ce-tag {
    color: #116329;
    @media (prefers-color-scheme: dark) {
      color: #7ee787;
    }
  }

  .ce-selector {
    color: #8250df;
    @media (prefers-color-scheme: dark) {
      color: #d2a8ff;
    }
  }

  .ce-variable {
    color: #953800;
    @media (prefers-color-scheme: dark) {
      color: #ffa657;
    }
  }

  .ce-heading {
    font-weight: bold;
    color: #0550ae;
    @media (prefers-color-scheme: dark) {
      color: #79c0ff;
    }
  }

  .ce-code {
    background: rgba(175, 184, 193, 0.2);
    padding: 2px 4px;
    border-radius: 3px;
  }

  .ce-bold {
    font-weight: bold;
  }

  .ce-italic {
    font-style: italic;
  }

  .ce-link {
    color: #0969da;
    @media (prefers-color-scheme: dark) {
      color: #58a6ff;
    }
  }

  /* Interactive Code Editor */
  .code-editor {
    display: block;
    margin: 12px 0;
    border-radius: 8px;
    overflow: hidden;
    border: 1px solid #e1e4e8;
    background: #f6f8fa;
    @media (prefers-color-scheme: dark) {
      border-color: #30363d;
      background: #161b22;
    }
  }

  .code-editor-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 8px 12px;
    background: #f1f3f5;
    border-bottom: 1px solid #e1e4e8;
    @media (prefers-color-scheme: dark) {
      background: #21262d;
      border-color: #30363d;
    }
  }

  .code-editor-lang {
    font-size: 12px;
    font-weight: 600;
    color: #57606a;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    @media (prefers-color-scheme: dark) {
      color: #8b949e;
    }
  }

  .code-editor-actions {
    display: flex;
    gap: 6px;
  }

  .code-editor-btn {
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 4px 10px;
    font-size: 12px;
    font-weight: 500;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.15s ease;
    font-family: system-ui;
  }

  .code-editor-btn.copy {
    background: #e1e4e8;
    color: #24292f;
    @media (prefers-color-scheme: dark) {
      background: #30363d;
      color: #c9d1d9;
    }
  }

  .code-editor-btn.copy:hover {
    background: #d0d7de;
    @media (prefers-color-scheme: dark) {
      background: #484f58;
    }
  }

  .code-editor-btn.run {
    background: #238636;
    color: #fff;
  }

  .code-editor-btn.run:hover {
    background: #2ea043;
  }

  .code-editor-btn svg {
    width: 14px;
    height: 14px;
  }

  .code-editor-body {
    position: relative;
  }

  .code-editor-textarea {
    display: block;
    width: 100%;
    min-height: 80px;
    padding: 12px;
    margin: 0;
    font-family: ui-monospace, SFMono-Regular, 'SF Mono', Menlo, Consolas, monospace;
    font-size: 14px;
    line-height: 1.5;
    tab-size: 2;
    border: none;
    outline: none;
    resize: none;
    background: transparent;
    color: transparent;
    caret-color: var(--text);
    white-space: pre;
    overflow: auto;
    position: relative;
    z-index: 1;
  }

  .code-editor-highlight {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    padding: 12px;
    margin: 0;
    font-family: ui-monospace, SFMono-Regular, 'SF Mono', Menlo, Consolas, monospace;
    font-size: 14px;
    line-height: 1.5;
    tab-size: 2;
    white-space: pre;
    pointer-events: none;
    overflow: auto;
    z-index: 0;
  }

  .code-editor-output {
    border-top: 1px solid #e1e4e8;
    background: #1b1f23;
    color: #c9d1d9;
    @media (prefers-color-scheme: dark) {
      border-color: #30363d;
    }
  }

  .code-editor-output-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 6px 12px;
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: #8b949e;
    background: #161b22;
  }

  .code-editor-output-clear {
    background: none;
    border: none;
    color: #8b949e;
    cursor: pointer;
    font-size: 11px;
    padding: 2px 6px;
    border-radius: 4px;
  }

  .code-editor-output-clear:hover {
    background: #30363d;
    color: #c9d1d9;
  }

  .code-editor-output-content {
    padding: 10px 12px;
    font-family: ui-monospace, SFMono-Regular, 'SF Mono', Menlo, Consolas, monospace;
    font-size: 13px;
    line-height: 1.5;
    max-height: 200px;
    overflow-y: auto;
    white-space: pre-wrap;
    word-break: break-word;
  }

  .code-editor-output-content:empty::before {
    content: 'No output yet. Click Run to execute.';
    color: #6e7681;
    font-style: italic;
  }

  .code-editor-output-content .log { color: #c9d1d9; }
  .code-editor-output-content .error { color: #f85149; }
  .code-editor-output-content .warn { color: #d29922; }
  .code-editor-output-content .info { color: #58a6ff; }

  #button {
    -webkit-tap-highlight-color: transparent;
    background-color: #0569fa;
    border-radius: 50%;
    border: none;
    bottom: 15px;
    box-shadow: 0 3px 5px -1px rgba(0, 0, 0, 0.2), 0 6px 10px 0 rgba(0, 0, 0, 0.14), 0 1px 18px 0 rgba(0, 0, 0, .12);
    color: #fff;
    cursor: pointer;
    display: grid;
    font-weight: 600;
    width: 46px;
    height: 46px;
    outline: none;
    overflow: hidden;
    padding: 0;
    place-items: center;
    position: fixed;
    right: 15px;
    text-decoration: none;
    touch-action: manipulation;
    transition: background-color .3s ease-out;
    user-select: none;
    z-index: 1;
  }

  @media (hover) {
    #button:hover {
      color: #fff;
      background-color: #3c86f3;
      box-shadow: 0 5px 5px -3px rgba(0, 0, 0, 0.2), 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, .12);
    }
  }

  #button:focus-visible {
    outline: 2px solid var(--outline);
    outline-offset: 2px;
  }

  span.ripple {
    position: absolute;
    border-radius: 50%;
    transform: scale(0);
    animation: ripple 600ms linear;
    background-color: rgba(255, 255, 255, 0.7);
  }

  @keyframes ripple {
    to {
      transform: scale(4);
      opacity: 0;
    }
  }

  #menu {
    visibility: hidden;
    transform: scale(0.9) translateY(20px);
    transition: all 100ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;
    opacity: 0;
    display: flex;
    flex-direction: column;
    width: 220px;
    position: fixed;
    right: 16px;
    bottom: 77px;
    box-shadow: 0 19px 38px rgba(0, 0, 0, 0.10), 0 15px 12px rgba(0, 0, 0, 0.05);
    background: var(--elevated);
    backdrop-filter: blur(10px);
    border-radius: 10px;
    z-index: 2;
  }

  #menu.visible {
    opacity: 1;
    transform: scale(1) translateY(0);
    visibility: visible;
  }

  #menu .item {
    display: flex;
    align-items: center;
    gap: 10px;
    cursor: pointer;
    text-decoration: none;
    text-align: left;
    padding: 10px 14px;
    overflow: hidden;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
    outline: none;
    border: none;
    touch-action: manipulation;
    font: 16px / 1.5 system-ui;
    color: var(--text);
  }

  #menu .item:hover {
    background-color: rgba(0, 0, 0, 0.04);
    @media (prefers-color-scheme: dark) {
      background-color: #353535;
    }
  }

  #menu .item:focus-within {
    outline: 2px solid var(--outline);
  }

  #menu .item:first-child {
    border-top-left-radius: 10px;
    border-top-right-radius: 10px;
  }

  #menu .item:last-child {
    border-bottom-left-radius: 10px;
    border-bottom-right-radius: 10px;
  }

  #notification {
    visibility: hidden;
    transform: translateY(-30px);
    transition: all 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;
    opacity: 0;

    display: flex;
    flex-direction: column;

    position: fixed;
    right: 17px;
    top: 17px;

    background: #5ad227;
    color: #fff;
    border-radius: 30px;
    font: 18px / 1 system-ui;
    font-weight: 600;
    z-index: 2;
    padding: 10px 20px;
  }

  #notification.visible {
    opacity: 1;
    transform: translateY(0);
    visibility: visible;
  }

  @media print {
    .noprint {
      visibility: hidden !important;
    }
  }
</style>
<article contenteditable="plaintext-only" spellcheck autofocus></article>
<button id="button" class="noprint">
  <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
       stroke="currentColor"
       stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <circle cx="12" cy="12" r="1"></circle>
    <circle cx="12" cy="5" r="1"></circle>
    <circle cx="12" cy="19" r="1"></circle>
  </svg>
</button>
<div id="menu" class="noprint" role="menu">
  <a class="item" href="#new" target="_blank" role="menuitem">
    <svg aria-hidden="true" focusable="false" width="22" height="22">
      <use xlink:href="#icon-plus"></use>
    </svg>
    New document
  </a>
  <a class="item" id="qr" href="/qr" role="menuitem">
    <svg aria-hidden="true" focusable="false" width="22" height="22">
      <use xlink:href="#icon-qrcode"></use>
    </svg>
    Generate QR code
  </a>
  <a class="item" id="share-link" href="" role="menuitem">
    <svg aria-hidden="true" focusable="false" width="22" height="22">
      <use xlink:href="#icon-share"></use>
    </svg>
    Share document
  </a>
  <a class="item" id="save-as-html" href="" role="menuitem">
    <svg aria-hidden="true" focusable="false" width="22" height="22">
      <use xlink:href="#icon-empty"></use>
    </svg>
    Save as HTML
  </a>
  <a class="item" id="save-as-text" href="" role="menuitem">
    <svg aria-hidden="true" focusable="false" width="22" height="22">
      <use xlink:href="#icon-empty"></use>
    </svg>
    Save as TEXT
  </a>
  <a class="item" href="https://github.com/antonmedv/textarea" target="_blank" role="menuitem">
    <svg aria-hidden="true" focusable="false" width="22" height="22">
      <use xlink:href="#icon-github"></use>
    </svg>
    GitHub
  </a>
</div>
<div id="notification" class="noprint"></div>
<script>
  initUI()

  const article = document.querySelector('article')
  const editor = new Editor(article, parseMarkdown)
  article.addEventListener('input', debounce(500, save))
  article.addEventListener('blur', save)
  article.addEventListener('click', event => {
    if (event.target.tagName === 'A') window.open(event.target.getAttribute('href'), '_blank')
  })
  addEventListener('DOMContentLoaded', load)
  addEventListener('hashchange', load)
  addEventListener('load', () => new MutationObserver(save).observe(article, {attributeFilter: ['style']}))
  addEventListener('keydown', e => {
    if ((e.metaKey || e.ctrlKey) && e.code === 'KeyS') {
      e.preventDefault()
      downloadHTML()
    }
  })
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('sw.js')
  }

  console.log('%cGitHub https://github.com/antonmedv/textarea', 'font-size: 16px; border: 1px solid lightblue; border-radius: 12px; padding: 10px 14px; ')

  async function load() {
    try {
      if (location.hash !== '') await set(location.hash)
      else {
        await set(localStorage.getItem('hash') ?? '')
        if (article.textContent) history.replaceState({}, '', await get())
      }
    } catch (e) {
      article.textContent = ''
      article.removeAttribute('style')
    }
    updateTitle()
  }

  async function save() {
    const hash = await get()
    if (location.hash !== hash) history.replaceState({}, '', hash)
    try {
      localStorage.setItem('hash', hash)
    } catch (e) {
    }
    updateTitle()
  }

  async function set(hash) {
    if (!hash) return
    const [content, style] = (await decompress(hash.slice(1))).split('\x00')
    editor.set(content)
    if (style) article.setAttribute('style', style)
  }

  async function get() {
    const style = article.getAttribute('style')
    const content = getArticleContent() + (style !== null ? '\x00' + style : '')
    return '#' + await compress(content)
  }

  function getArticleContent() {
    let content = ''
    const walk = (node) => {
      if (node.nodeType === Node.TEXT_NODE) {
        content += node.textContent
      } else if (node.classList?.contains('code-editor')) {
        content += node.dataset.raw || ''
      } else if (node.childNodes) {
        node.childNodes.forEach(walk)
      }
    }
    walk(article)
    return content
  }

  function updateTitle() {
    const content = getArticleContent()
    const match = content.match(/^\n*#(.+)\n/)
    document.title = match?.[1] ?? 'Textarea'
  }

  async function compress(string) {
    const byteArray = new TextEncoder().encode(string)
    const stream = new CompressionStream('deflate-raw')
    const writer = stream.writable.getWriter()
    writer.write(byteArray)
    writer.close()
    const buffer = await new Response(stream.readable).arrayBuffer()
    return new Uint8Array(buffer).toBase64({alphabet: 'base64url'})
  }

  async function decompress(b64) {
    const byteArray = Uint8Array.fromBase64(b64, {alphabet: 'base64url'})
    const stream = new DecompressionStream('deflate-raw')
    const writer = stream.writable.getWriter()
    writer.write(byteArray)
    writer.close()
    const buffer = await new Response(stream.readable).arrayBuffer()
    return new TextDecoder().decode(buffer)
  }

  function debounce(ms, fn) {
    let timer
    return (...args) => {
      clearTimeout(timer)
      timer = setTimeout(() => fn(...args), ms)
    }
  }

  async function downloadHTML() {
    updateTitle()
    const doc = document.documentElement.cloneNode(true)
    doc.querySelectorAll('script').forEach(s => s.remove())
    doc.querySelectorAll('.noprint').forEach(s => s.remove())
    doc.querySelector('article').removeAttribute('contenteditable')
    const html = '<!DOCTYPE html>\n' + doc.outerHTML

    if ('showSaveFilePicker' in window) {
      try {
        const handle = await showSaveFilePicker({
          suggestedName: document.title + '.html',
          types: [{
            description: 'HTML file',
            accept: {'text/html': ['.html']},
          }],
        })
        const writable = await handle.createWritable()
        await writable.write(html)
        await writable.close()
        return
      } catch (e) {
        if (e.name === 'AbortError') return
      }
    }

    const blob = new Blob([html], {type: 'text/html'})
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = document.title + '.html'
    a.click()
    URL.revokeObjectURL(url)
  }

  async function downloadTXT() {
    updateTitle()
    const text = getArticleContent()

    if ('showSaveFilePicker' in window) {
      try {
        const handle = await showSaveFilePicker({
          suggestedName: document.title + '.txt',
          types: [{
            description: 'TEXT file',
            accept: {'text/plain': ['.txt']},
          }],
        })
        const writable = await handle.createWritable()
        await writable.write(text)
        await writable.close()
        return
      } catch (e) {
        if (e.name === 'AbortError') return
      }
    }

    const blob = new Blob([text], {type: 'text/plain'})
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = document.title + '.txt'
    a.click()
    URL.revokeObjectURL(url)
  }

  let codeEditorLoaded = false
  let codeEditorLoadPromise = null

  function loadCodeEditor() {
    if (codeEditorLoaded) return Promise.resolve()
    if (codeEditorLoadPromise) return codeEditorLoadPromise

    codeEditorLoadPromise = new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = 'code-editor.js'
      script.onload = () => {
        codeEditorLoaded = true
        resolve()
      }
      script.onerror = reject
      document.head.appendChild(script)
    })
    return codeEditorLoadPromise
  }

  function hasCodeBlocks(content) {
    return /```\w*\n[\s\S]*?\n```/.test(content)
  }

  async function createCodeEditor(rawCode) {
    await loadCodeEditor()
    return window.CodeEditor.create(rawCode, save)
  }

  function parseMarkdown() {
    const input = getArticleContent()
    const frag = document.createDocumentFragment()
    const codeBlockPlaceholders = [] // Track code blocks for async loading

    let cursorPos = null
    try {
      const sel = window.getSelection()
      if (sel.rangeCount > 0) {
        let offset = 0
        const walk = (node) => {
          if (node === sel.anchorNode) {
            offset += sel.anchorOffset
            return true
          }
          if (node.nodeType === Node.TEXT_NODE) {
            offset += node.textContent.length
          } else if (node.classList?.contains('code-editor') || node.classList?.contains('code-editor-placeholder')) {
            offset += (node.dataset.raw || '').length
          } else if (node.childNodes) {
            for (const child of node.childNodes) {
              if (walk(child)) return true
            }
          }
          return false
        }
        walk(article)
        cursorPos = offset
      }
    } catch (e) {}

    const matchers = [
      {name: 'md-codeblock', re: /```[^\n]*\n[\s\S]*?\n```/y},
      {name: 'md-codeblock', re: /~~~[^\n]*\n[\s\S]*?\n~~~/y},
      {name: 'md-h1', re: /^#[ \t]+[^\n]*$/my},
      {name: 'md-h2', re: /^##[ \t]+[^\n]*$/my},
      {name: 'md-h3', re: /^###[ \t]+[^\n]*$/my},
      {name: 'md-h4', re: /^####[ \t]+[^\n]*$/my},
      {name: 'md-h5', re: /^#####[ \t]+[^\n]*$/my},
      {name: 'md-h6', re: /^######[ \t]+[^\n]*$/my},
      {name: 'md-code', re: /`[^`\n]*`/y},
      {name: 'md-bold', re: /\*\*[^*\n]+?\*\*/y},
      {name: 'md-bold', re: /__[^_\n]+?__/y},
      {name: 'md-strike', re: /~~[^~\n]+?~~/y},
      {name: 'md-italic', re: /\*[^*\n]+?\*/y},
      {name: 'md-italic', re: /_[^_\n]+?_/y},
      {name: 'md-url', re: /https?:\/\/[^\s<>()\[\]{}"'`]+/y},
    ]

    const specials = ['`', '~', '*', '#', '_', 'h']

    let i = 0
    while (i < input.length) {
      let matched = false
      for (const m of matchers) {
        m.re.lastIndex = i
        const res = m.re.exec(input)
        if (res && res.index === i) {
          const raw = res[0]
          if (m.name === 'md-url') {
            const a = document.createElement('a')
            a.className = 'md-url'
            a.href = raw
            a.textContent = raw
            a.target = '_blank'
            a.rel = 'noopener noreferrer'
            frag.appendChild(a)
          } else if (m.name === 'md-codeblock' && /^```\w+/i.test(raw)) {
            const placeholder = document.createElement('div')
            placeholder.className = 'code-editor-placeholder'
            placeholder.dataset.raw = raw
            placeholder.style.cssText = 'min-height: 80px; background: #f6f8fa; border-radius: 8px; margin: 12px 0;'
            frag.appendChild(placeholder)
            // Track start position for cursor focus
            codeBlockPlaceholders.push({ placeholder, raw, startPos: i, endPos: i + raw.length })
          } else {
            const span = document.createElement('span')
            span.className = m.name
            span.textContent = raw
            frag.appendChild(span)
          }
          i += raw.length
          matched = true
          break
        }
      }

      if (matched) continue

      let next = input.length
      for (const ch of specials) {
        const idx = input.indexOf(ch, i)
        if (idx !== -1 && idx < next) next = idx
      }

      if (next === i) {
        frag.appendChild(document.createTextNode(input[i]))
        i++
        continue
      }

      frag.appendChild(document.createTextNode(input.slice(i, next)))
      i = next
    }

    article.textContent = ''
    article.appendChild(frag)
    article.normalize()

    const lastChild = article.lastChild
    if (lastChild?.classList?.contains('code-editor-placeholder') || lastChild?.classList?.contains('code-editor')) {
      article.appendChild(document.createTextNode('\n'))
    }

    if (codeBlockPlaceholders.length > 0) {
      loadCodeEditor().then(() => {
        let focusedEditor = null
        codeBlockPlaceholders.forEach(({ placeholder, raw, startPos, endPos }) => {
          if (placeholder.parentNode) {
            const editor = window.CodeEditor.create(raw, save)
            placeholder.parentNode.replaceChild(editor, placeholder)
            
            if (cursorPos !== null && cursorPos >= startPos && cursorPos <= endPos) {
              focusedEditor = editor
              const firstNewline = raw.indexOf('\n')
              const codeStart = firstNewline + 1
              const codeEnd = raw.length - 4 
              const relativePos = cursorPos - startPos
              
              if (relativePos > codeStart && relativePos < raw.length) {
                // Cursor is in the code body area
                const textarea = editor.querySelector('.code-editor-textarea')
                if (textarea) {
                  const codeBody = raw.slice(codeStart, codeEnd).trim()
                  const posInCode = Math.min(Math.max(0, relativePos - codeStart), codeBody.length)
                  setTimeout(() => {
                    textarea.focus()
                    textarea.setSelectionRange(posInCode, posInCode)
                  }, 0)
                }
              }
            }
          }
        })
      }).catch(err => {
        console.error('Failed to load code editor:', err)
        codeBlockPlaceholders.forEach(({ placeholder, raw }) => {
          if (placeholder.parentNode) {
            const span = document.createElement('span')
            span.className = 'md-codeblock'
            span.textContent = raw
            placeholder.parentNode.replaceChild(span, placeholder)
          }
        })
      })
    }
  }

  function initUI() {
    const menu = document.querySelector('#menu')
    const button = document.querySelector('#button')
    const qr = document.querySelector('#qr')
    const shareLink = document.querySelector('#share-link')
    const saveAsHTML = document.querySelector('#save-as-html')
    const saveAsText = document.querySelector('#save-as-text')

    button.addEventListener('click', event => {
      if (event.clientX || event.targetTouches) ripple(event)
      menu.classList.toggle('visible')
      qr.setAttribute('href', '/qr' + location.hash)
      shareLink.setAttribute('href', location.href)
    })

    function hideMenu() {
      menu.classList.remove('visible')
    }

    function notify(message) {
      const notification = document.querySelector('#notification')
      notification.classList.add('visible')
      notification.textContent = message
      setTimeout(() => notification.classList.remove('visible'), 2e3)
    }

    document.body.addEventListener('click', event => {
      let t = event.target
      if (t.closest('#menu')) return
      if (t.closest('#button')) return
      if (t.closest('.ripple')) return
      menu.classList.remove('visible')
    })

    shareLink.addEventListener('click', event => {
      event.preventDefault()
      if (!navigator.clipboard) {
        alert('Your browser does not support clipboard API')
        return
      }
      navigator.clipboard.writeText(location.href)
      notify('Link copied')
      hideMenu()
    })
    saveAsHTML.addEventListener('click', event => {
      event.preventDefault()
      downloadHTML()
      hideMenu()
    })
    saveAsText.addEventListener('click', event => {
      event.preventDefault()
      downloadTXT()
      hideMenu()
    })
  }

  function ripple(event) {
    const button = event.currentTarget
    const circle = document.createElement('span')
    const diameter = Math.max(button.clientWidth, button.clientHeight)
    const radius = diameter / 2
    circle.style.width = circle.style.height = `${diameter}px`
    circle.style.left = `${(event.clientX || event.targetTouches[0].pageX) - button.offsetLeft - radius}px`
    circle.style.top = `${(event.clientY || event.targetTouches[0].pageY) - button.offsetTop - radius}px`
    circle.classList.add('ripple')
    const ripple = button.getElementsByClassName('ripple')[0]
    if (ripple) ripple.remove()
    button.appendChild(circle)
  }

  function Editor(element, highlight) {
    const listeners = []
    const history = []
    let at = -1, prev

    const isInsideCodeEditor = () => {
      const sel = window.getSelection()
      if (!sel.anchorNode) return false
      let node = sel.anchorNode
      while (node && node !== element) {
        if (node.classList?.contains('code-editor')) return true
        node = node.parentNode
      }
      return false
    }

    const debounceHighlight = debounce(30, () => {
      if (isInsideCodeEditor()) return
      const pos = save()
      highlight(element)
      restore(pos)
    })

    const shouldRecord = (event) => {
      return !isUndo(event) && !isRedo(event)
        && event.key !== 'Meta'
        && event.key !== 'Control'
        && event.key !== 'Alt'
        && !event.key.startsWith('Arrow')
    }

    let recording = false
    const debounceRecordHistory = debounce(300, (event) => {
      if (shouldRecord(event)) {
        recordHistory()
        recording = false
      }
    })

    const on = (type, fn) => {
      listeners.push([type, fn])
      element.addEventListener(type, fn)
    }
    on('keydown', event => {
      if (event.defaultPrevented) return
      prev = toString()
      if (isUndo(event)) doUndo(event)
      if (isRedo(event)) doRedo(event)
      if (shouldRecord(event) && !recording) {
        recordHistory()
        recording = true
      }
    })
    on('keyup', event => {
      if (event.defaultPrevented) return
      if (event.isComposing) return
      if (prev !== toString()) debounceHighlight()
      debounceRecordHistory(event)
    })
    on('paste', () => setTimeout(recordHistory, 10))
    on('cut', () => setTimeout(recordHistory, 10))
    on('beforeinput', event => {
      if (event.inputType === 'historyUndo') doUndo(event)
      if (event.inputType === 'historyRedo') doRedo(event)
    })

    function save() {
      const s = getSelection()
      const pos = {start: 0, end: 0, dir: undefined}
      let {anchorNode, anchorOffset, focusNode, focusOffset} = s
      if (!anchorNode || !focusNode) throw 'error1'
      if (anchorNode === element && focusNode === element) {
        pos.start = (anchorOffset > 0 && element.textContent) ? element.textContent.length : 0
        pos.end = (focusOffset > 0 && element.textContent) ? element.textContent.length : 0
        pos.dir = (focusOffset >= anchorOffset) ? '->' : '<-'
        return pos
      }
      if (anchorNode.nodeType === Node.ELEMENT_NODE) {
        const node = document.createTextNode('')
        anchorNode.insertBefore(node, anchorNode.childNodes[anchorOffset])
        anchorNode = node
        anchorOffset = 0
      }
      if (focusNode.nodeType === Node.ELEMENT_NODE) {
        const node = document.createTextNode('')
        focusNode.insertBefore(node, focusNode.childNodes[focusOffset])
        focusNode = node
        focusOffset = 0
      }
      visit(element, el => {
        if (el === anchorNode && el === focusNode) {
          pos.start += anchorOffset
          pos.end += focusOffset
          pos.dir = anchorOffset <= focusOffset ? '->' : '<-'
          return 'stop'
        }
        if (el === anchorNode) {
          pos.start += anchorOffset
          if (!pos.dir) {
            pos.dir = '->'
          } else {
            return 'stop'
          }
        } else if (el === focusNode) {
          pos.end += focusOffset
          if (!pos.dir) {
            pos.dir = '<-'
          } else {
            return 'stop'
          }
        }
        if (el.nodeType === Node.TEXT_NODE) {
          if (pos.dir !== '->') pos.start += el.nodeValue.length
          if (pos.dir !== '<-') pos.end += el.nodeValue.length
        }
        if (el.classList?.contains('code-editor') || el.classList?.contains('code-editor-placeholder')) {
          const rawLen = (el.dataset.raw || '').length
          if (pos.dir !== '->') pos.start += rawLen
          if (pos.dir !== '<-') pos.end += rawLen
        }
      })

      element.normalize()
      return pos
    }

    function restore(pos) {
      const s = getSelection()
      let startNode, startOffset = 0
      let endNode, endOffset = 0

      if (!pos.dir) pos.dir = '->'
      if (pos.start < 0) pos.start = 0
      if (pos.end < 0) pos.end = 0

      if (pos.dir === '<-') {
        const {start, end} = pos
        pos.start = end
        pos.end = start
      }

      let current = 0

      visit(element, el => {
        if (el.classList?.contains('code-editor') || el.classList?.contains('code-editor-placeholder')) {
          const len = (el.dataset.raw || '').length
          current += len
          return
        }

        if (el.nodeType !== Node.TEXT_NODE) return

        const len = (el.nodeValue || '').length
        if (current + len >= pos.start) {
          if (!startNode) {
            startNode = el
            startOffset = pos.start - current
          }
          if (current + len >= pos.end) {
            endNode = el
            endOffset = pos.end - current
            return 'stop'
          }
        }
        current += len
      })

      if (!startNode) {
        startNode = element
        startOffset = element.childNodes.length
      }
      if (!endNode) {
        endNode = element
        endOffset = element.childNodes.length
      }

      if (pos.dir === '<-') {
        [startNode, startOffset, endNode, endOffset] = [endNode, endOffset, startNode, startOffset]
      }

      {
        const startEl = uneditable(startNode)
        if (startEl) {
          const node = document.createTextNode('')
          startEl.parentNode?.insertBefore(node, startEl.nextSibling)
          startNode = node
          startOffset = 0
        }
        const endEl = uneditable(endNode)
        if (endEl) {
          const node = document.createTextNode('')
          endEl.parentNode?.insertBefore(node, endEl.nextSibling)
          endNode = node
          endOffset = 0
        }
      }

      s.setBaseAndExtent(startNode, startOffset, endNode, endOffset)
      element.normalize()
    }

    function uneditable(node) {
      while (node && node !== element) {
        if (node.nodeType === Node.ELEMENT_NODE) {
          if (node.getAttribute('contenteditable') === 'false') {
            return node
          }
        }
        node = node.parentNode
      }
    }

    function doUndo(event) {
      preventDefault(event)
      at--
      const record = history[at]
      if (record) {
        element.innerHTML = record.html
        restore(record.pos)
      }
      if (at < 0) at = 0
    }

    function doRedo(event) {
      preventDefault(event)
      at++
      const record = history[at]
      if (record) {
        element.innerHTML = record.html
        restore(record.pos)
      }
      if (at >= history.length) at--
    }

    function recordHistory() {
      const html = element.innerHTML
      const pos = save()
      const lastRecord = history[at]
      if (
        lastRecord
        && lastRecord.html === html
        && lastRecord.pos.start === pos.start
        && lastRecord.pos.end === pos.end
      ) return
      at++
      history[at] = {html, pos}
      history.splice(at + 1)
      const maxHistory = 10_000
      if (at > maxHistory) {
        at = maxHistory
        history.splice(0, 1)
      }
    }

    function visit(editor, visitor) {
      const queue = []
      if (editor.firstChild) queue.push(editor.firstChild)
      let el = queue.pop()
      while (el) {
        if (visitor(el) === 'stop') break
        if (el.nextSibling) queue.push(el.nextSibling)
        if (el.firstChild && !el.classList?.contains('code-editor') && !el.classList?.contains('code-editor-placeholder')) queue.push(el.firstChild)
        el = queue.pop()
      }
    }

    function isCtrl(event) {
      return event.metaKey || event.ctrlKey
    }

    function isUndo(event) {
      return isCtrl(event) && !event.shiftKey && event.code === 'KeyZ'
    }

    function isRedo(event) {
      return isCtrl(event) && event.shiftKey && event.code === 'KeyZ'
    }

    function toString() {
      return element.textContent || ''
    }

    function preventDefault(event) {
      event.preventDefault()
    }

    function getSelection() {
      return element.getRootNode().getSelection()
    }

    return {
      set(content) {
        element.textContent = content
        highlight(element)
      },
      destroy() {
        for (const [type, fn] of listeners) editor.removeEventListener(type, fn)
      },
    }
  }
</script>
<svg style="display: none" aria-hidden="true" focusable="false">
  <symbol id="icon-plus" viewBox="0 0 24 24" fill="none" stroke="currentColor"
          stroke-width="1.25" stroke-linecap="round" stroke-linejoin="round"
          class="icon icon-tabler icons-tabler-outline icon-tabler-plus">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
    <path d="M12 5l0 14"/>
    <path d="M5 12l14 0"/>
  </symbol>
  <symbol id="icon-share" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.25"
          stroke-linecap="round"
          stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
    <path d="M8 9h-1a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-8a2 2 0 0 0 -2 -2h-1"/>
    <path d="M12 14v-11"/>
    <path d="M9 6l3 -3l3 3"/>
  </symbol>
  <symbol id="icon-qrcode" viewBox="0 0 24 24" fill="none" stroke="currentColor"
          stroke-width="1.25" stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
    <path d="M4 5a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1l0 -4"/>
    <path d="M7 17l0 .01"/>
    <path d="M14 5a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1l0 -4"/>
    <path d="M7 7l0 .01"/>
    <path d="M4 15a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1l0 -4"/>
    <path d="M17 7l0 .01"/>
    <path d="M14 14l3 0"/>
    <path d="M20 14l0 .01"/>
    <path d="M14 14l0 3"/>
    <path d="M14 20l3 0"/>
    <path d="M17 17l3 0"/>
    <path d="M20 17l0 3"/>
  </symbol>
  <symbol id="icon-github" viewBox="0 0 24 24" fill="none" stroke="currentColor"
          stroke-width="1.25" stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
    <path
      d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5"/>
  </symbol>
  <symbol id="icon-empty" viewBox="0 0 24 24"></symbol>
</svg>
